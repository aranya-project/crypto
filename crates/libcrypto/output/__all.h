/*
 * Copyright (c) SpiderOak, Inc. All rights reserved.
 */
 

#ifndef OPENSSL_HEADER_ALL_H
#define OPENSSL_HEADER_ALL_H

#pragma once

/* Code generated by `cbindgen`. DO NOT EDIT. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <openssl/base.h>

/**
 * Unused.
 */
typedef struct ENGINE ENGINE;


/**
 * A specific AEAD algorithm.
 */
typedef struct OPENSSL_ALIGNED(8) EVP_AEAD {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[96];
} EVP_AEAD;

/**
 * An AEAD instance.
 */
typedef struct OPENSSL_ALIGNED(8) EVP_AEAD_CTX {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[24];
} EVP_AEAD_CTX;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns the size in bytes of the AEAD's key.
 */
size_t EVP_AEAD_key_length(const struct EVP_AEAD *OPENSSL_NON_NULL aead);

/**
 * Returns the size in bytes of the AEAD's nonce.
 */
size_t EVP_AEAD_nonce_length(const struct EVP_AEAD *OPENSSL_NON_NULL aead);

/**
 * Returns the size in bytes of the AEAD's authentication
 * overhead.
 */
size_t EVP_AEAD_max_overhead(const struct EVP_AEAD *OPENSSL_NON_NULL aead);

/**
 * See [`EVP_AEAD_max_overhead`].
 */
size_t EVP_AEAD_max_tag_len(const struct EVP_AEAD *OPENSSL_NON_NULL aead);

/**
 *AES-128-GCM
 *Returns `NULL` if the AEAD is not supported.
 */
const struct EVP_AEAD *EVP_aead_aes_128_gcm(void);

/**
 *AES-256-GCM
 *Returns `NULL` if the AEAD is not supported.
 */
const struct EVP_AEAD *EVP_aead_aes_256_gcm(void);

/**
 *AES-128-GCM for TLS v1.3
 *Returns `NULL` if the AEAD is not supported.
 */
const struct EVP_AEAD *EVP_aead_aes_128_gcm_tls13(void);

/**
 *AES-256-GCM for TLS v1.3
 *Returns `NULL` if the AEAD is not supported.
 */
const struct EVP_AEAD *EVP_aead_aes_256_gcm_tls13(void);

/**
 *ChaCha20Poly1305
 *Returns `NULL` if the AEAD is not supported.
 */
const struct EVP_AEAD *EVP_aead_chacha20_poly1305(void);

/**
 * Sets an uninitialized `ctx` to all zeros.
 *
 * `ctx` must still be initialized with [`EVP_AEAD_CTX_init`]
 * before use.
 *
 * It is safe to call [`EVP_AEAD_CTX_cleanup`] after calling
 * this routine.
 *
 * # Safety
 *
 * - You must uphold Rust's aliasing requirements.
 */
void EVP_AEAD_CTX_zero(struct EVP_AEAD_CTX *ctx);

/**
 * Initializes `ctx` for the given AEAD algorithm.
 *
 * - `key_len` must match [`EVP_AEAD_key_len(aead)`].
 * - If non-zero, `tag_len` must match
 *   [`EVP_AEAD_tag_len(aead)`].
 * - `impl_` must be null.
 *
 * It returns 1 on success and 0 otherwise. It is safe to call
 * [`EVP_AEAD_CTX_cleanup`] on error.
 *
 * # Safety
 *
 * - `ctx`, `aead`, and `key` must be non-null and suitably
 *   aligned.
 * - `key` must be valid for reads up to `key_len` bytes.
 * - `key_len` must be less than or equal to than
 *   [`isize::MAX`].
 */
int EVP_AEAD_CTX_init(struct EVP_AEAD_CTX *ctx,
                      const struct EVP_AEAD *aead,
                      const uint8_t *key,
                      size_t key_len,
                      size_t tag_len,
                      const struct ENGINE *impl_);

/**
 * Frees all resources used by `ctx`.
 *
 * # Safety
 *
 * - If non-null, `ctx` must have been initialized with
 *   `EVP_AEAD_CTX_init`.
 */
void EVP_AEAD_CTX_cleanup(struct EVP_AEAD_CTX *ctx);

/**
 * Encrypts and authenticates `in_len` bytes from `in_`,
 * authenticates `ad_len` bytes from `ad`, and writes the
 * resulting ciphertext to `out`.
 *
 * At most `max_out_len` bytes are written to `out`. On success,
 * `out_len` is updated with the number of bytes written to
 * `out`.
 *
 * It returns 1 on success and 0 otherwise.
 *
 * - `max_out_len` must be at least `in_len` plus the result of
 *   [`EVP_AEAD_max_overhead`].
 * - `nonce_len` must be equal to the result of
 *   [`EVP_AEAD_nonce_length`].
 * - If `nonce_len` is zero, `nonce` must be null.
 * - If `in_` is null, `in_len` must be zero.
 * - If `in_` is non-null, `in_len` must be non-zero.
 * - If `ad` is null, `ad_len` must be zero.
 * - If `ad` is non-null, `ad_len` must be non-zero.
 * - `out` and `in_` must overlap entirely or not at all.
 *
 * # Safety
 *
 * - `ctx` and `out_len` must be non-null and suitably aligned.
 * - If non-null, all other pointers must be suitably aligned.
 * - If non-null, `out` must be valid for writes up to
 *   `max_out_len` bytes.
 * - `max_out_len` must be at most `isize::MAX`.
 * - If non-null, `nonce` must be valid for reads up to
 *   `nonce_len` bytes.
 * - `nonce_len` must be at most `isize::MAX`.
 * - If non-null, `in_` must be valid for reads up to `in_len`
 *   bytes.
 * - `in_len` must be at most `isize::MAX`.
 * - If non-null `ad` must be valid for reads up to `ad_len`
 *   bytes.
 * - `ad_len` must be at most `isize::MAX`.
 */
int EVP_AEAD_CTX_seal(const struct EVP_AEAD_CTX *ctx,
                      uint8_t *out,
                      size_t *out_len,
                      size_t max_out_len,
                      const uint8_t *nonce,
                      size_t nonce_len,
                      const uint8_t *in_,
                      size_t in_len,
                      const uint8_t *ad,
                      size_t ad_len);

/**
 * Decrypts and authenticates `in_len` bytes from `in_`,
 * authenticates `ad_len` bytes from `ad`, and writes the
 * resulting plaintext to `out`.
 *
 * At most `max_out_len` bytes are written to `out`. On success,
 * `out_len` is updated with the number of bytes written to
 * `out`.
 *
 * It returns 1 on success and 0 otherwise.
 *
 * - `max_out_len` must be at least `in_len` less the result of
 *   [`EVP_AEAD_max_overhead`].
 * - `nonce_len` must be equal to the result of
 *   [`EVP_AEAD_nonce_length`].
 * - If `nonce_len` is zero, `nonce` must be null.
 * - If `in_` is null, `in_len` must be zero.
 * - If `in_` is non-null, `in_len` must be non-zero.
 * - If `ad` is null, `ad_len` must be zero.
 * - If `ad` is non-null, `ad_len` must be non-zero.
 * - `out` and `in_` must overlap entirely or not at all.
 *
 * # Safety
 *
 * - `ctx` and `out_len` must be non-null and suitably aligned.
 * - If non-null, all other pointers must be suitably aligned.
 * - If non-null, `out` must be valid for writes up to
 *   `max_out_len` bytes.
 * - `max_out_len` must be at most `isize::MAX`.
 * - If non-null, `nonce` must be valid for reads up to
 *   `nonce_len` bytes.
 * - `nonce_len` must be at most `isize::MAX`.
 * - If non-null, `in_` must be valid for reads up to `in_len`
 *   bytes.
 * - `in_len` must be at most `isize::MAX`.
 * - If non-null `ad` must be valid for reads up to `ad_len`
 *   bytes.
 * - `ad_len` must be at most `isize::MAX`.
 */
int EVP_AEAD_CTX_open(const struct EVP_AEAD_CTX *ctx,
                      uint8_t *out,
                      size_t *out_len,
                      size_t max_out_len,
                      const uint8_t *nonce,
                      size_t nonce_len,
                      const uint8_t *in_,
                      size_t in_len,
                      const uint8_t *ad,
                      size_t ad_len);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* OPENSSL_HEADER_ALL_H */


