//! Code generation for `spideroak-libcrypto`.

mod aead;
mod cipher;
mod error;
mod util;

use std::{collections::HashMap, env, fs, path::Path};

use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

pub use crate::{aead::AEADS, error::BuildError};

/// Formats a [`TokenStream`] as a string.
pub fn format(tokens: &TokenStream) -> String {
    let mut data = tokens.to_string();
    if let Ok(file) = syn::parse_file(&data) {
        data = prettyplease::unparse(&file);
    }
    data
}

/// Builds [`Bindings`].
#[derive(Clone, Debug)]
pub struct Builder {
    libcrypto: Ident,
    max_aead_size: usize,
    max_aead_align: usize,
}

impl Builder {
    /// Creates a `Builder`.
    pub fn new() -> Self {
        Self {
            libcrypto: format_ident!("__spideroak_libcrypto"),
            max_aead_size: 512,
            max_aead_align: 16,
        }
    }

    /// Sets the maximum AEAD size.
    pub fn with_max_aead_size(mut self, size: usize) -> Self {
        self.max_aead_size = size;
        self
    }

    /// Sets the maximum AEAD alignment.
    pub fn with_max_aead_align(mut self, align: usize) -> Self {
        self.max_aead_align = align;
        self
    }

    /// Generates the bindings.
    pub fn build(self) -> Bindings {
        Bindings {
            libcrypto: self.libcrypto,
            max_aead_size: self.max_aead_size,
            max_aead_align: self.max_aead_align,
        }
    }
}

impl Default for Builder {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

/// Generated bindings.
pub struct Bindings {
    pub(crate) libcrypto: Ident,
    max_aead_size: usize,
    max_aead_align: usize,
}

impl Bindings {
    /// Writes the headers to `dir`.
    pub fn generate_headers<P: AsRef<Path>>(&self, dir: P) -> anyhow::Result<()> {
        let headers = Headers {
            max_aead_size: self.max_aead_size,
            max_aead_align: self.max_aead_align,
        };
        headers.generate(dir)
    }

    /// Generates the Rust code.
    pub fn generate_code(&self) -> Result<TokenStream, BuildError> {
        let aead = self.aead()?;
        let cipher = self.cipher()?;

        let Self { libcrypto, .. } = self;

        let code = quote! {
            // This code is @generated by
            // `spideroak-libcrypto-codegen`. DO NOT EDIT.

            extern crate spideroak_libcrypto as #libcrypto;

            #aead
            #cipher
        };
        Ok(code)
    }
}

/// Generated headers.
struct Headers {
    max_aead_size: usize,
    max_aead_align: usize,
}

impl Headers {
    /// Writes the headers to `dir`.
    fn generate<P: AsRef<Path>>(self, dir: P) -> anyhow::Result<()> {
        let dir = dir.as_ref().join("openssl");
        fs::create_dir_all(&dir)?;

        static BASE_H: &str = include_str!("headers/base.h");

        static DUMMY: &[&str] = &[
            "aead", "aes", "asn1", "bn", "crypto", "des", "dh", "digest", "ec", "ecdsa", "err",
            "evp", "hkdf", "hmac", "md5", "mem", "nid", "objects", "ocsp", "opensslv", "pem",
            "rand", "rc4", "rsa", "sha", "x509", "x598v3",
        ];
        for name in DUMMY {
            fs::write(dir.join(format!("{name}.h")), Self::dummy(name))?;
        }

        fs::write(dir.join("base.h"), BASE_H)?;
        self.write_all(&dir.join("__all.h"))?;
        self.write_cfg(&dir.join("__config.h"))?;

        Ok(())
    }

    fn dummy(name: &str) -> String {
        let upper = name.to_uppercase();
        format!(
            r#"
#ifndef OPENSSL_HEADER_{upper}_H
#define OPENSSL_HEADER_{upper}_H

#include <openssl/__all.h>

#endif // OPENSSL_HEADER_{upper}_H
"#
        )
    }

    /// Generates `__all.h`.
    fn write_all(&self, path: &Path) -> anyhow::Result<()> {
        use cbindgen::{
            Braces, Builder, Config, DocumentationLength, DocumentationStyle, Language, RenameRule,
            Style, VERSION,
        };

        TraceLogger::init().unwrap();

        let mut cfg = Config::default();
        cfg.language = Language::C;
        cfg.include_guard = Some("OPENSSL_HEADER_ALL_H".to_string());
        cfg.pragma_once = true;
        cfg.autogen_warning = Some(format!(
            "/* Code generated by `cbindgen {VERSION}`. DO NOT EDIT. */",
        ));
        cfg.sys_includes = vec![
            "stdint.h".to_string(),
            "stddef.h".to_string(),
            "openssl/base.h".to_string(),
        ];
        cfg.no_includes = true;
        cfg.cpp_compat = true;
        cfg.braces = Braces::SameLine;
        cfg.line_length = 80;
        cfg.tab_width = 4;
        cfg.documentation = true;
        cfg.documentation_style = DocumentationStyle::Doxy;
        cfg.documentation_length = DocumentationLength::Full;
        cfg.usize_is_size_t = true;
        cfg.style = Style::Both;
        cfg.defines = HashMap::from_iter(
            [
                ("target_os = macos", "__APPLE__"),
                ("target_os = linux", "__linux__"),
                ("target_os = vxworks", "__vxworks__"),
                ("target_arch = x86_64", "__x86_64__"),
            ]
            .map(|(k, v)| (k.to_owned(), v.to_owned())),
        );
        cfg.enumeration.rename_variants = RenameRule::ScreamingSnakeCase;
        cfg.enumeration.prefix_with_name = true;
        cfg.enumeration.must_use = Some("OPENSSL_MUST_USE".to_string());
        cfg.function.must_use = Some("OPENSSL_MUST_USE".to_string());
        cfg.function.no_return = Some("OPENSSL_NO_RETURN".to_string());
        cfg.layout.packed = Some("OPENSSL_PACKED".to_string());
        cfg.layout.aligned_n = Some("OPENSSL_ALIGNED".to_string());
        cfg.parse.clean = true;
        cfg.parse.expand.default_features = false;
        cfg.parse.expand.crates = vec!["spideroak-libcrypto-rust".to_owned()];
        cfg.pointer.non_null_attribute = Some("OPENSSL_NON_NULL".to_string());
        cfg.structure.must_use = Some("OPENSSL_DESIGNATED_INIT".to_string());

        // Set `RUSTC_BOOTSTRAP=1` because `-Zunpretty=expanded`
        // is unstable.
        //
        // SAFETY: We're running single-threaded.
        let _guard = unsafe { TempVar::new("RUSTC_BOOTSTRAP", "1") };
        let bindings = Builder::new().with_config(cfg).with_crate(".").generate()?;
        bindings.write_to_file(path);
        Ok(())
    }

    /// Generates `__config.h`.
    fn write_cfg(&self, path: &Path) -> anyhow::Result<()> {
        let Self {
            max_aead_size,
            max_aead_align,
        } = self;

        let buf = format!(
            r#"
#ifndef OPENSSL_HEADER_CONFIG_H
#define OPENSSL_HEADER_CONFIG_H

#include <openssl/base.h>

#if defined(__cplusplus)
extern "C" {{
#endif

enum {{
    OPENSSL_EVP_AEAD_CTX_SIZE = {max_aead_size},
    OPENSSL_EVP_AEAD_CTX_ALIGN = {max_aead_align},
}}

#if defined(__cplusplus)
}} // extern "C"
#endif

#endif /* OPENSSL_HEADER_CONFIG_H */
"#
        );
        fs::write(path, buf)?;
        Ok(())
    }
}

struct TempVar<'a> {
    key: &'a str,
}

impl<'a> TempVar<'a> {
    /// # Safety
    ///
    /// See [`env::set_var`] and [`env::remove_var`].
    unsafe fn new(key: &'a str, val: &str) -> Self {
        // SAFETY: See the function's safety docs.
        unsafe { env::set_var(key, val) }

        Self { key }
    }
}
impl Drop for TempVar<'_> {
    fn drop(&mut self) {
        // SAFETY: See the constructor's safety docs.
        unsafe { env::remove_var(self.key) }
    }
}

struct TraceLogger;

impl TraceLogger {
    pub fn init() -> Result<(), log::SetLoggerError> {
        log::set_logger(&TraceLogger)?;
        log::set_max_level(log::LevelFilter::Trace);
        Ok(())
    }
}

impl log::Log for TraceLogger {
    fn enabled(&self, metadata: &log::Metadata<'_>) -> bool {
        metadata.level() <= log::Level::Trace
    }

    fn log(&self, record: &log::Record<'_>) {
        if self.enabled(record.metadata()) {
            println!("cargo::warning={}: {}", record.level(), record.args());
        }
    }

    fn flush(&self) {
        use std::io::Write;

        std::io::stderr().flush().unwrap();
    }
}
